"""
Backend Flask para Inventario Ciego - Render Deploy
Conecta a Azure PostgreSQL
"""
from flask import Flask, request, jsonify, send_from_directory, send_file
from flask_cors import CORS
import psycopg2
from psycopg2.pool import SimpleConnectionPool
from psycopg2.extras import RealDictCursor
import os
from decimal import Decimal
from io import BytesIO
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side

from flask.json.provider import DefaultJSONProvider

class CustomJSONProvider(DefaultJSONProvider):
    def default(self, obj):
        if isinstance(obj, Decimal):
            return float(obj)
        return super().default(obj)

app = Flask(__name__, static_folder='static')
app.json_provider_class = CustomJSONProvider
app.json = CustomJSONProvider(app)
CORS(app, origins=['https://inventario-ciego-5bdr.onrender.com'])

@app.after_request
def add_no_cache_headers(response):
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

# Configuracion de la base de datos Azure PostgreSQL
DB_CONFIG = {
    'host': os.environ.get('DB_HOST', 'chiosburguer.postgres.database.azure.com'),
    'database': os.environ.get('DB_NAME', 'InventariosLocales'),
    'user': os.environ.get('DB_USER', 'adminChios'),
    'password': os.environ.get('DB_PASSWORD', 'Burger2023'),
    'port': os.environ.get('DB_PORT', '5432'),
    'sslmode': 'require',
    'keepalives': 1,
    'keepalives_idle': 30,
    'keepalives_interval': 10,
    'keepalives_count': 5,
    'connect_timeout': 10
}

_connection_pool = None

def _get_pool():
    global _connection_pool
    if _connection_pool is None:
        _connection_pool = SimpleConnectionPool(
            minconn=1, maxconn=5,
            **DB_CONFIG, cursor_factory=RealDictCursor
        )
    return _connection_pool

def get_db():
    """Obtiene conexion del pool, validando que este viva"""
    conn = _get_pool().getconn()
    try:
        conn.cursor().execute("SELECT 1")
        conn.rollback()
    except Exception:
        # Conexion stale - cerrar y crear nueva
        try:
            _get_pool().putconn(conn, close=True)
        except Exception:
            try:
                conn.close()
            except Exception:
                pass
        conn = psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)
    return conn

def release_db(conn):
    try:
        if conn.closed:
            return
        _get_pool().putconn(conn)
    except Exception:
        try:
            conn.close()
        except Exception:
            pass


# Helper: mapeo de IDs de bodega a nombres legibles
BODEGAS_NOMBRES = {
    'real_audiencia': 'Real Audiencia',
    'floreana': 'Floreana',
    'portugal': 'Portugal',
    'santo_cachon_real': 'Santo Cachon Real',
    'santo_cachon_portugal': 'Santo Cachon Portugal',
    'simon_bolon': 'Simon Bolon'
}

# Mapeo de usuario a bodega asignada (None = acceso a todas)
USUARIO_BODEGA = {
    'admin': None,
    'contador1': None,
    'contador2': None,
    'real': 'real_audiencia',
    'floreana': 'floreana',
    'portugal': 'portugal',
    'santocachonreal': 'santo_cachon_real',
    'santocachonportugal': 'santo_cachon_portugal',
    'simonbolon': 'simon_bolon'
}

# ==================== RUTAS ESTATICAS ====================

@app.route('/')
def index():
    import json as json_lib, base64
    # Inyectar personas directamente en el HTML como JSON en data attribute (evita problemas de encoding en script)
    personas = _personas_cache['datos'] if _personas_cache['datos'] else []
    if not personas:
        try:
            personas = _cargar_personas_airtable()
        except Exception:
            pass
    html_path = os.path.join(app.static_folder, 'index.html')
    with open(html_path, 'r', encoding='utf-8') as f:
        html = f.read()
    # Usar base64 para evitar cualquier problema de encoding/caracteres especiales
    personas_json = json_lib.dumps(personas, ensure_ascii=True)
    personas_b64 = base64.b64encode(personas_json.encode('utf-8')).decode('ascii')
    inject = f'<script id="personas-data" type="application/json">{personas_json}</script>\n'
    inject += f'<meta name="personas-b64" content="{personas_b64}">\n'
    html = html.replace('</head>', inject + '</head>')
    return html

@app.route('/<path:path>')
def static_files(path):
    return send_from_directory('static', path)

# ==================== API ====================

_login_attempts = {}

def _check_rate_limit(ip, max_attempts=5, window=60):
    now = _time.time()
    attempts = _login_attempts.get(ip, [])
    attempts = [t for t in attempts if now - t < window]
    _login_attempts[ip] = attempts
    return len(attempts) < max_attempts

def _record_login_attempt(ip):
    now = _time.time()
    if ip not in _login_attempts:
        _login_attempts[ip] = []
    _login_attempts[ip].append(now)

@app.route('/api/login', methods=['POST'])
def login():
    ip = request.remote_addr
    if not _check_rate_limit(ip):
        return jsonify({'success': False, 'error': 'Demasiados intentos. Espera 60 segundos.'}), 429

    data = request.json
    username = data.get('username')
    password = data.get('password')

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT username, nombre, rol FROM inventario_diario.usuarios
            WHERE username = %s AND password = %s AND activo = TRUE
        """, (username, password))
        user = cur.fetchone()

        if user:
            bodega_asignada = USUARIO_BODEGA.get(user['username'])
            return jsonify({
                'success': True,
                'user': {
                    'username': user['username'],
                    'nombre': user['nombre'],
                    'rol': user['rol'],
                    'bodega': bodega_asignada
                }
            })

        _record_login_attempt(ip)
        return jsonify({'success': False, 'error': 'Credenciales invalidas'}), 401
    except Exception as e:
        print(f"Error en /api/login: {e}")
        return jsonify({'success': False, 'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)

@app.route('/api/categorias', methods=['GET'])
def get_categorias():
    # Categorias estaticas
    categorias = [
        {'id': 1, 'nombre': 'Bebidas'},
        {'id': 2, 'nombre': 'Carnes'},
        {'id': 3, 'nombre': 'Lacteos'},
        {'id': 4, 'nombre': 'Congelados'},
        {'id': 5, 'nombre': 'Otros'}
    ]
    return jsonify(categorias)

@app.route('/api/bodegas', methods=['GET'])
def get_bodegas():
    bodegas = [
        {'id': 'real_audiencia', 'nombre': 'Real Audiencia'},
        {'id': 'floreana', 'nombre': 'Floreana'},
        {'id': 'portugal', 'nombre': 'Portugal'},
        {'id': 'santo_cachon_real', 'nombre': 'Santo Cachon Real'},
        {'id': 'santo_cachon_portugal', 'nombre': 'Santo Cachon Portugal'},
        {'id': 'simon_bolon', 'nombre': 'Simon Bolon'}
    ]
    return jsonify(bodegas)

@app.route('/api/inventario/consultar', methods=['GET'])
def consultar_inventario():
    fecha = request.args.get('fecha')
    local = request.args.get('local')

    if not fecha or not local:
        return jsonify({'error': 'Fecha y local son requeridos'}), 400

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        # Asegurar que la columna observaciones existe
        cur.execute("""
            ALTER TABLE inventario_diario.inventario_ciego_conteos
            ADD COLUMN IF NOT EXISTS observaciones TEXT
        """)
        conn.commit()

        cur.execute("""
            SELECT id, codigo, nombre, unidad, cantidad, cantidad_contada, cantidad_contada_2, observaciones,
                   COALESCE(costo_unitario, 0) as costo_unitario
            FROM inventario_diario.inventario_ciego_conteos
            WHERE fecha = %s AND local = %s
            ORDER BY codigo
        """, (fecha, local))

        productos = cur.fetchall()

        # Incluir personas del cache (nunca bloquea, solo datos en memoria)
        personas = _personas_cache['datos']

        return jsonify({'productos': productos, 'personas': personas})
    except Exception as e:
        print(f"Error en /api/inventario/consultar: {e}")
        if conn:
            try:
                conn.rollback()
            except Exception:
                pass
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)

@app.route('/api/inventario/guardar-conteo', methods=['POST'])
def guardar_conteo():
    data = request.json
    id_producto = data.get('id')
    cantidad = data.get('cantidad_contada')
    conteo = data.get('conteo', 1)

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        if conteo == 2:
            cur.execute("""
                UPDATE inventario_diario.inventario_ciego_conteos
                SET cantidad_contada_2 = %s
                WHERE id = %s
            """, (cantidad, id_producto))
        else:
            cur.execute("""
                UPDATE inventario_diario.inventario_ciego_conteos
                SET cantidad_contada = %s
                WHERE id = %s
            """, (cantidad, id_producto))

        conn.commit()

        return jsonify({'success': True})
    except Exception as e:
        print(f"Error en /api/inventario/guardar-conteo: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)

@app.route('/api/inventario/guardar-observacion', methods=['POST'])
def guardar_observacion():
    data = request.json
    id_producto = data.get('id')
    observaciones = data.get('observaciones', '')

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("""
            UPDATE inventario_diario.inventario_ciego_conteos
            SET observaciones = %s
            WHERE id = %s
        """, (observaciones, id_producto))
        conn.commit()

        return jsonify({'success': True})
    except Exception as e:
        print(f"Error en /api/inventario/guardar-observacion: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)

@app.route('/api/inventario/cargar', methods=['POST'])
def cargar_inventario():
    """Endpoint para cargar datos desde el script de Selenium"""
    data = request.json
    fecha = data.get('fecha')
    local = data.get('local')
    productos = data.get('productos', [])

    if not fecha or not local or not productos:
        return jsonify({'error': 'Datos incompletos'}), 400

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        registros = 0
        for prod in productos:
            cur.execute("""
                INSERT INTO inventario_diario.inventario_ciego_conteos
                (fecha, local, codigo, nombre, unidad, cantidad)
                VALUES (%s, %s, %s, %s, %s, %s)
                ON CONFLICT (fecha, local, codigo)
                DO UPDATE SET cantidad = EXCLUDED.cantidad, nombre = EXCLUDED.nombre
            """, (fecha, local, prod['codigo'], prod['nombre'], prod['unidad'], prod['cantidad']))
            registros += 1

        conn.commit()

        return jsonify({'success': True, 'registros': registros})
    except Exception as e:
        print(f"Error en /api/inventario/cargar: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)

@app.route('/api/historico', methods=['GET'])
def historico():
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    bodega = request.args.get('bodega')

    if not fecha_desde or not fecha_hasta:
        return jsonify({'error': 'fecha_desde y fecha_hasta son requeridos'}), 400

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        query = """
            SELECT
                fecha,
                local,
                COUNT(*) as total_productos,
                COUNT(cantidad_contada) as total_contados,
                COUNT(CASE WHEN COALESCE(cantidad_contada_2, cantidad_contada) IS NOT NULL
                    AND COALESCE(cantidad_contada_2, cantidad_contada) - cantidad != 0
                    THEN 1 END) as total_con_diferencia,
                COUNT(CASE WHEN cantidad_contada IS NOT NULL THEN 1 END) as total_con_conteo1,
                COUNT(CASE WHEN cantidad_contada_2 IS NOT NULL THEN 1 END) as total_con_conteo2
            FROM inventario_diario.inventario_ciego_conteos
            WHERE fecha >= %s AND fecha <= %s
        """
        params = [fecha_desde, fecha_hasta]

        if bodega:
            query += " AND local = %s"
            params.append(bodega)

        query += " GROUP BY fecha, local ORDER BY fecha DESC, local"

        cur.execute(query, params)
        resultados = cur.fetchall()

        # Calcular estado para cada registro
        datos = []
        for r in resultados:
            total = r['total_productos']
            contados = r['total_contados']
            con_conteo2 = r['total_con_conteo2']

            if con_conteo2 > 0 or (contados == total and r['total_con_diferencia'] == 0):
                estado = 'completo'
            elif contados > 0:
                estado = 'en_proceso'
            else:
                estado = 'pendiente'

            porcentaje = round((contados / total * 100) if total > 0 else 0)

            datos.append({
                'fecha': str(r['fecha']),
                'local': r['local'],
                'total_productos': total,
                'total_contados': contados,
                'total_con_diferencia': r['total_con_diferencia'],
                'estado': estado,
                'porcentaje': porcentaje
            })

        return jsonify(datos)
    except Exception as e:
        print(f"Error en /api/historico: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/reportes/diferencias', methods=['GET'])
def reporte_diferencias():
    fecha = request.args.get('fecha')
    bodega = request.args.get('bodega')

    if not fecha:
        return jsonify({'error': 'fecha es requerida'}), 400

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        query = """
            SELECT codigo, nombre, unidad, cantidad as sistema,
                   cantidad_contada as conteo1,
                   cantidad_contada_2 as conteo2,
                   COALESCE(cantidad_contada_2, cantidad_contada) - cantidad as diferencia,
                   observaciones,
                   local
            FROM inventario_diario.inventario_ciego_conteos
            WHERE fecha = %s
              AND COALESCE(cantidad_contada_2, cantidad_contada) IS NOT NULL
              AND COALESCE(cantidad_contada_2, cantidad_contada) - cantidad != 0
        """
        params = [fecha]

        if bodega:
            query += " AND local = %s"
            params.append(bodega)

        query += " ORDER BY ABS(COALESCE(cantidad_contada_2, cantidad_contada) - cantidad) DESC"

        cur.execute(query, params)
        productos = cur.fetchall()

        # Convertir Decimal a float
        datos = []
        for p in productos:
            item = {
                'codigo': p['codigo'],
                'nombre': p['nombre'],
                'unidad': p['unidad'],
                'sistema': float(p['sistema']) if p['sistema'] is not None else 0,
                'conteo1': float(p['conteo1']) if p['conteo1'] is not None else None,
                'conteo2': float(p['conteo2']) if p['conteo2'] is not None else None,
                'diferencia': float(p['diferencia']) if p['diferencia'] is not None else 0,
                'observaciones': p['observaciones'] or ''
            }
            if not bodega:
                item['local'] = p['local']
                item['local_nombre'] = BODEGAS_NOMBRES.get(p['local'], p['local'])
            datos.append(item)

        return jsonify(datos)
    except Exception as e:
        print(f"Error en /api/reportes/diferencias: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/reportes/exportar-excel', methods=['GET'])
def exportar_excel():
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    bodega = request.args.get('bodega')

    if not fecha_desde or not fecha_hasta:
        return jsonify({'error': 'fecha_desde y fecha_hasta son requeridos'}), 400

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        query = """
            SELECT fecha, local, codigo, nombre, unidad,
                   cantidad as sistema,
                   cantidad_contada as conteo1,
                   cantidad_contada_2 as conteo2,
                   COALESCE(cantidad_contada_2, cantidad_contada) - cantidad as diferencia,
                   observaciones
            FROM inventario_diario.inventario_ciego_conteos
            WHERE fecha >= %s AND fecha <= %s
        """
        params = [fecha_desde, fecha_hasta]

        if bodega:
            query += " AND local = %s"
            params.append(bodega)

        query += " ORDER BY fecha, local, codigo"

        cur.execute(query, params)
        registros = cur.fetchall()

        # Crear workbook
        wb = Workbook()
        wb.remove(wb.active)

        # Estilos
        header_font = Font(name='Calibri', bold=True, color='FFFFFF', size=11)
        header_fill = PatternFill(start_color='1E3A5F', end_color='1E3A5F', fill_type='solid')
        header_alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
        thin_border = Border(
            left=Side(style='thin', color='E2E8F0'),
            right=Side(style='thin', color='E2E8F0'),
            top=Side(style='thin', color='E2E8F0'),
            bottom=Side(style='thin', color='E2E8F0')
        )
        dif_neg_fill = PatternFill(start_color='FEF2F2', end_color='FEF2F2', fill_type='solid')
        dif_neg_font = Font(name='Calibri', bold=True, color='B91C1C')
        dif_pos_fill = PatternFill(start_color='ECFDF5', end_color='ECFDF5', fill_type='solid')
        dif_pos_font = Font(name='Calibri', bold=True, color='059669')

        # Agrupar por fecha+local
        grupos = {}
        for r in registros:
            key = (str(r['fecha']), r['local'])
            if key not in grupos:
                grupos[key] = []
            grupos[key].append(r)

        headers = ['Codigo', 'Producto', 'Unidad', 'Sistema', 'Conteo 1', 'Conteo 2', 'Diferencia', 'Observaciones']

        for (fecha, local), items in grupos.items():
            sheet_name = f"{fecha}_{local}"[:31]
            ws = wb.create_sheet(title=sheet_name)

            # Headers
            for col_idx, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col_idx, value=header)
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = header_alignment
                cell.border = thin_border

            # Datos
            for row_idx, item in enumerate(items, 2):
                vals = [
                    item['codigo'],
                    item['nombre'],
                    item['unidad'],
                    float(item['sistema']) if item['sistema'] is not None else 0,
                    float(item['conteo1']) if item['conteo1'] is not None else '',
                    float(item['conteo2']) if item['conteo2'] is not None else '',
                    float(item['diferencia']) if item['diferencia'] is not None else '',
                    item['observaciones'] or ''
                ]
                for col_idx, val in enumerate(vals, 1):
                    cell = ws.cell(row=row_idx, column=col_idx, value=val)
                    cell.border = thin_border
                    # Colorear diferencias
                    if col_idx == 7 and val != '' and val != 0:
                        if val < 0:
                            cell.fill = dif_neg_fill
                            cell.font = dif_neg_font
                        else:
                            cell.fill = dif_pos_fill
                            cell.font = dif_pos_font

            # Auto-width
            for col in ws.columns:
                max_length = 0
                column_letter = col[0].column_letter
                for cell in col:
                    if cell.value:
                        max_length = max(max_length, len(str(cell.value)))
                ws.column_dimensions[column_letter].width = min(max_length + 4, 40)

        if not wb.sheetnames:
            ws = wb.create_sheet(title='Sin datos')
            ws.cell(row=1, column=1, value='No se encontraron registros para el rango seleccionado')

        output = BytesIO()
        wb.save(output)
        output.seek(0)

        filename = f"inventario_{fecha_desde}_a_{fecha_hasta}.xlsx"

        return send_file(
            output,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            as_attachment=True,
            download_name=filename
        )
    except Exception as e:
        print(f"Error en /api/reportes/exportar-excel: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/reportes/tendencias', methods=['GET'])
def reporte_tendencias():
    bodega = request.args.get('bodega')
    limite = request.args.get('limite', 20, type=int)

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        query = """
            SELECT
                codigo,
                nombre,
                COUNT(*) as frecuencia,
                ROUND(AVG(ABS(COALESCE(cantidad_contada_2, cantidad_contada) - cantidad))::numeric, 3) as promedio_desviacion,
                ROUND(SUM(COALESCE(cantidad_contada_2, cantidad_contada) - cantidad)::numeric, 3) as diferencia_acumulada
            FROM inventario_diario.inventario_ciego_conteos
            WHERE COALESCE(cantidad_contada_2, cantidad_contada) IS NOT NULL
              AND COALESCE(cantidad_contada_2, cantidad_contada) - cantidad != 0
        """
        params = []

        if bodega:
            query += " AND local = %s"
            params.append(bodega)

        query += """
            GROUP BY codigo, nombre
            ORDER BY frecuencia DESC, promedio_desviacion DESC
            LIMIT %s
        """
        params.append(limite)

        cur.execute(query, params)
        productos = cur.fetchall()

        datos = []
        for i, p in enumerate(productos, 1):
            datos.append({
                'ranking': i,
                'codigo': p['codigo'],
                'nombre': p['nombre'],
                'frecuencia': p['frecuencia'],
                'promedio_desviacion': float(p['promedio_desviacion']) if p['promedio_desviacion'] else 0,
                'diferencia_acumulada': float(p['diferencia_acumulada']) if p['diferencia_acumulada'] else 0
            })

        return jsonify(datos)
    except Exception as e:
        print(f"Error en /api/reportes/tendencias: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/reportes/dashboard', methods=['GET'])
def reporte_dashboard():
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')

    if not fecha_desde or not fecha_hasta:
        return jsonify({'error': 'fecha_desde y fecha_hasta son requeridos'}), 400

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        cur.execute("""
            SELECT
                local,
                COUNT(*) as total_productos,
                COUNT(cantidad_contada) as total_contados,
                COUNT(CASE WHEN COALESCE(cantidad_contada_2, cantidad_contada) IS NOT NULL
                    AND COALESCE(cantidad_contada_2, cantidad_contada) - cantidad != 0
                    THEN 1 END) as total_con_diferencia,
                COALESCE(ROUND(AVG(ABS(
                    CASE WHEN COALESCE(cantidad_contada_2, cantidad_contada) IS NOT NULL
                         AND COALESCE(cantidad_contada_2, cantidad_contada) - cantidad != 0
                    THEN COALESCE(cantidad_contada_2, cantidad_contada) - cantidad END
                ))::numeric, 3), 0) as promedio_diferencia_abs,
                COUNT(CASE WHEN COALESCE(cantidad_contada_2, cantidad_contada) IS NOT NULL
                    AND COALESCE(cantidad_contada_2, cantidad_contada) - cantidad < 0
                    THEN 1 END) as total_faltantes,
                COUNT(CASE WHEN COALESCE(cantidad_contada_2, cantidad_contada) IS NOT NULL
                    AND COALESCE(cantidad_contada_2, cantidad_contada) - cantidad > 0
                    THEN 1 END) as total_sobrantes
            FROM inventario_diario.inventario_ciego_conteos
            WHERE fecha >= %s AND fecha <= %s
            GROUP BY local
            ORDER BY local
        """, (fecha_desde, fecha_hasta))

        resultados = cur.fetchall()

        datos = []
        for r in resultados:
            datos.append({
                'local': r['local'],
                'local_nombre': BODEGAS_NOMBRES.get(r['local'], r['local']),
                'total_productos': r['total_productos'],
                'total_contados': r['total_contados'],
                'total_con_diferencia': r['total_con_diferencia'],
                'promedio_diferencia_abs': float(r['promedio_diferencia_abs']),
                'total_faltantes': r['total_faltantes'],
                'total_sobrantes': r['total_sobrantes']
            })

        return jsonify(datos)
    except Exception as e:
        print(f"Error en /api/reportes/dashboard: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/reportes/tendencias-temporal', methods=['GET'])
def reporte_tendencias_temporal():
    bodega = request.args.get('bodega')
    dias = request.args.get('dias', 30, type=int)

    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()

        query = """
            SELECT
                fecha,
                local,
                COUNT(CASE WHEN COALESCE(cantidad_contada_2, cantidad_contada) IS NOT NULL
                    AND COALESCE(cantidad_contada_2, cantidad_contada) - cantidad != 0
                    THEN 1 END) as total_con_diferencia
            FROM inventario_diario.inventario_ciego_conteos
            WHERE fecha >= CURRENT_DATE - %s
        """
        params = [dias]

        if bodega:
            query += " AND local = %s"
            params.append(bodega)

        query += " GROUP BY fecha, local ORDER BY fecha, local"

        cur.execute(query, params)
        resultados = cur.fetchall()

        # Agrupar por fecha y series por bodega
        fechas_set = set()
        series_dict = {}
        for r in resultados:
            fecha_str = str(r['fecha'])
            local = r['local']
            fechas_set.add(fecha_str)
            if local not in series_dict:
                series_dict[local] = {}
            series_dict[local][fecha_str] = r['total_con_diferencia']

        fechas = sorted(fechas_set)
        series = {}
        for local, valores in series_dict.items():
            series[local] = {
                'nombre': BODEGAS_NOMBRES.get(local, local),
                'datos': [valores.get(f, 0) for f in fechas]
            }

        return jsonify({
            'fechas': fechas,
            'series': series
        })
    except Exception as e:
        print(f"Error en /api/reportes/tendencias-temporal: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


# ============================================================
# MODULO: Asignacion de Diferencias
# ============================================================

import base64 as _b64
_AIRTABLE_FB = _b64.b64decode('cGF0TVYzOFJhOTBhQXprRlAuZWRhNTE1Y2E4MjkzYjI1ODJjYTdmODVmYzNlMGE4NTllNzRjMjhhNWZkOTY0YjA4Zjg2NTJiMjk3MzRjNTg0Nw==').decode()
def _get_airtable_token():
    return os.environ.get('AIRTABLE_TOKEN', '') or _AIRTABLE_FB
AIRTABLE_BASE = os.environ.get('AIRTABLE_BASE', 'appzTllAjxu4TOs1a')
AIRTABLE_TABLE = os.environ.get('AIRTABLE_TABLE', 'tbldYTLfQ3DoEK0WA')

# Cache de personas en memoria del servidor
import time as _time
_personas_cache = {'datos': [], 'timestamp': 0}
PERSONAS_CACHE_TTL = 3600  # 1 hora

# Mapeo de bodega a centros de costo de Airtable
BODEGA_CENTROS = {
    'real_audiencia': ['Chios Real Audiencia'],
    'floreana': ['Chios Floreana'],
    'portugal': ['Chios Portugal'],
    'santo_cachon_real': ['Santo Cachon Real Audiencia', 'Santo Cach\u00f3n Real Audiencia'],
    'santo_cachon_portugal': ['Santo Cachon Portugal', 'Santo Cach\u00f3n Portugal'],
    'simon_bolon': ['Simon Bolon Real Audiencia', 'Sim\u00f3n Bol\u00f3n Real Audiencia'],
}

# ============================================================
# MODULO: Cruce Operativo (bodegas operativas)
# ============================================================

BODEGAS_OPERATIVAS = {
    'bodega_principal': 'Bodega Principal',
    'materia_prima': 'Materia Prima',
    'planta': 'Planta de Produccion'
}

@app.route('/api/cruce/ejecuciones', methods=['GET'])
def cruce_ejecuciones():
    """Lista ejecuciones del cruce operativo con filtros"""
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    bodega = request.args.get('bodega')
    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()
        sql = """SELECT * FROM inventario_diario.cruce_operativo_ejecuciones WHERE 1=1"""
        params = []
        if fecha_desde:
            sql += " AND fecha_toma >= %s"
            params.append(fecha_desde)
        if fecha_hasta:
            sql += " AND fecha_toma <= %s"
            params.append(fecha_hasta)
        if bodega:
            sql += " AND bodega = %s"
            params.append(bodega)
        sql += " ORDER BY fecha_toma DESC, bodega"
        cur.execute(sql, params)
        rows = cur.fetchall()
        result = []
        for r in rows:
            result.append({
                'id': r['id'],
                'fecha_toma': r['fecha_toma'].isoformat() if r['fecha_toma'] else None,
                'bodega': r['bodega'],
                'bodega_nombre': BODEGAS_OPERATIVAS.get(r['bodega'], r['bodega']),
                'estado': r['estado'],
                'total_productos_toma': r['total_productos_toma'],
                'total_productos_contifico': r['total_productos_contifico'],
                'total_cruzados': r['total_cruzados'],
                'total_con_diferencia': r['total_con_diferencia'],
                'timestamp_deteccion': r['timestamp_deteccion'].isoformat() if r['timestamp_deteccion'] else None,
                'timestamp_cruce': r['timestamp_cruce'].isoformat() if r['timestamp_cruce'] else None,
                'error_msg': r['error_msg'],
            })
        return jsonify(result)
    except Exception as e:
        print(f"Error en /api/cruce/ejecuciones: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/cruce/detalle', methods=['GET'])
def cruce_detalle():
    """Detalle producto por producto de un cruce"""
    ejec_id = request.args.get('ejecucion_id')
    solo_dif = request.args.get('solo_diferencias', 'false').lower() == 'true'
    if not ejec_id:
        return jsonify({'error': 'ejecucion_id requerido'}), 400
    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()
        sql = """SELECT * FROM inventario_diario.cruce_operativo_detalle
                 WHERE ejecucion_id = %s"""
        if solo_dif:
            sql += " AND diferencia != 0"
        sql += " ORDER BY ABS(valor_diferencia) DESC"
        cur.execute(sql, (ejec_id,))
        rows = cur.fetchall()
        result = []
        for r in rows:
            result.append({
                'id': r['id'],
                'codigo': r['codigo'],
                'nombre': r['nombre'],
                'categoria': r['categoria'],
                'unidad': r['unidad'],
                'cantidad_toma': float(r['cantidad_toma']) if r['cantidad_toma'] is not None else None,
                'cantidad_sistema': float(r['cantidad_sistema']) if r['cantidad_sistema'] is not None else None,
                'diferencia': float(r['diferencia']) if r['diferencia'] is not None else None,
                'costo_unitario': float(r['costo_unitario']) if r['costo_unitario'] is not None else 0,
                'valor_diferencia': float(r['valor_diferencia']) if r['valor_diferencia'] is not None else 0,
                'tipo_abc': r['tipo_abc'],
                'origen': r['origen'],
            })
        return jsonify(result)
    except Exception as e:
        print(f"Error en /api/cruce/detalle: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/cruce/resumen', methods=['GET'])
def cruce_resumen():
    """KPIs: ultima ejecucion por bodega, totales, valor diferencias"""
    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("""
            WITH ultimas AS (
                SELECT DISTINCT ON (bodega) id, bodega, fecha_toma,
                       total_productos_toma, total_con_diferencia
                FROM inventario_diario.cruce_operativo_ejecuciones
                WHERE estado = 'completado'
                ORDER BY bodega, fecha_toma DESC
            )
            SELECT u.id, u.bodega, u.fecha_toma, u.total_productos_toma, u.total_con_diferencia,
                   COALESCE(SUM(d.valor_diferencia) FILTER (WHERE d.diferencia != 0), 0) as valor_total,
                   COUNT(*) FILTER (WHERE d.diferencia < 0) as faltantes,
                   COUNT(*) FILTER (WHERE d.diferencia > 0) as sobrantes
            FROM ultimas u
            LEFT JOIN inventario_diario.cruce_operativo_detalle d ON d.ejecucion_id = u.id
            GROUP BY u.id, u.bodega, u.fecha_toma, u.total_productos_toma, u.total_con_diferencia
            ORDER BY u.bodega
        """)
        rows = cur.fetchall()

        resumen = []
        for r in rows:
            resumen.append({
                'bodega': r['bodega'],
                'bodega_nombre': BODEGAS_OPERATIVAS.get(r['bodega'], r['bodega']),
                'fecha_toma': r['fecha_toma'].isoformat() if r['fecha_toma'] else None,
                'total_productos_toma': r['total_productos_toma'],
                'total_con_diferencia': r['total_con_diferencia'],
                'valor_total_diferencias': float(r['valor_total']),
                'faltantes': r['faltantes'],
                'sobrantes': r['sobrantes'],
            })
        return jsonify(resumen)
    except Exception as e:
        print(f"Error en /api/cruce/resumen: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/cruce/exportar-excel', methods=['GET'])
def cruce_exportar_excel():
    """Exporta detalle de un cruce a Excel"""
    ejec_id = request.args.get('ejecucion_id')
    if not ejec_id:
        return jsonify({'error': 'ejecucion_id requerido'}), 400
    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()
        # Info ejecucion
        cur.execute("SELECT * FROM inventario_diario.cruce_operativo_ejecuciones WHERE id = %s", (ejec_id,))
        ejec = cur.fetchone()
        if not ejec:
            return jsonify({'error': 'Ejecucion no encontrada'}), 404

        # Detalle
        cur.execute("""SELECT * FROM inventario_diario.cruce_operativo_detalle
                       WHERE ejecucion_id = %s ORDER BY ABS(valor_diferencia) DESC""", (ejec_id,))
        rows = cur.fetchall()

        wb = Workbook()
        ws = wb.active
        bodega_nombre = BODEGAS_OPERATIVAS.get(ejec['bodega'], ejec['bodega'])
        ws.title = f"{bodega_nombre}"[:31]

        header_font = Font(bold=True, color='FFFFFF', size=11)
        header_fill = PatternFill(start_color='1E3A5F', end_color='1E3A5F', fill_type='solid')
        red_font = Font(color='B91C1C', bold=True)
        green_font = Font(color='059669', bold=True)
        red_fill = PatternFill(start_color='FEF2F2', end_color='FEF2F2', fill_type='solid')
        green_fill = PatternFill(start_color='ECFDF5', end_color='ECFDF5', fill_type='solid')
        yellow_fill = PatternFill(start_color='FFFBEB', end_color='FFFBEB', fill_type='solid')
        gray_fill = PatternFill(start_color='F1F5F9', end_color='F1F5F9', fill_type='solid')
        thin_border = Border(
            left=Side(style='thin'), right=Side(style='thin'),
            top=Side(style='thin'), bottom=Side(style='thin'))

        headers = ['Codigo', 'Producto', 'Categoria', 'Tipo', 'Unidad',
                   'Fisico', 'Sistema', 'Diferencia', 'Costo Unit.', 'Valor Dif.', 'Origen']
        for col, h in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=h)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border

        for i, r in enumerate(rows, 2):
            vals = [r['codigo'], r['nombre'], r['categoria'], r['tipo_abc'], r['unidad'],
                    float(r['cantidad_toma']) if r['cantidad_toma'] is not None else 0,
                    float(r['cantidad_sistema']) if r['cantidad_sistema'] is not None else 0,
                    float(r['diferencia']) if r['diferencia'] is not None else 0,
                    float(r['costo_unitario']) if r['costo_unitario'] is not None else 0,
                    float(r['valor_diferencia']) if r['valor_diferencia'] is not None else 0,
                    r['origen']]
            for col, v in enumerate(vals, 1):
                cell = ws.cell(row=i, column=col, value=v)
                cell.border = thin_border
            dif = vals[7]
            origen = vals[10]
            if dif < 0:
                for col in range(1, len(vals) + 1):
                    ws.cell(row=i, column=col).fill = red_fill
                ws.cell(row=i, column=8).font = red_font
            elif dif > 0:
                for col in range(1, len(vals) + 1):
                    ws.cell(row=i, column=col).fill = green_fill
                ws.cell(row=i, column=8).font = green_font
            if origen == 'solo_toma':
                for col in range(1, len(vals) + 1):
                    ws.cell(row=i, column=col).fill = yellow_fill
            elif origen == 'solo_contifico':
                for col in range(1, len(vals) + 1):
                    ws.cell(row=i, column=col).fill = gray_fill

        for col in range(1, len(headers) + 1):
            ws.column_dimensions[ws.cell(row=1, column=col).column_letter].width = 15

        output = BytesIO()
        wb.save(output)
        output.seek(0)
        fecha_str = ejec['fecha_toma'].strftime('%Y-%m-%d') if ejec['fecha_toma'] else 'sin-fecha'
        filename = f"cruce_{ejec['bodega']}_{fecha_str}.xlsx"
        return send_file(output, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                         as_attachment=True, download_name=filename)
    except Exception as e:
        print(f"Error en /api/cruce/exportar-excel: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/cruce/tendencias', methods=['GET'])
def cruce_tendencias():
    """Top productos con diferencias recurrentes"""
    conn = None
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT d.codigo, d.nombre, d.categoria,
                   COUNT(*) as veces_con_diferencia,
                   ROUND(AVG(ABS(d.diferencia))::numeric, 2) as promedio_dif_abs,
                   ROUND(SUM(d.valor_diferencia)::numeric, 2) as valor_total
            FROM inventario_diario.cruce_operativo_detalle d
            JOIN inventario_diario.cruce_operativo_ejecuciones e ON d.ejecucion_id = e.id
            WHERE d.diferencia != 0 AND e.estado = 'completado'
            GROUP BY d.codigo, d.nombre, d.categoria
            HAVING COUNT(*) >= 2
            ORDER BY valor_total DESC
            LIMIT 30
        """)
        rows = cur.fetchall()
        result = []
        for r in rows:
            result.append({
                'codigo': r['codigo'],
                'nombre': r['nombre'],
                'categoria': r['categoria'],
                'veces_con_diferencia': r['veces_con_diferencia'],
                'promedio_dif_abs': float(r['promedio_dif_abs']),
                'valor_total': float(r['valor_total']),
            })
        return jsonify(result)
    except Exception as e:
        print(f"Error en /api/cruce/tendencias: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/admin/borrar-datos', methods=['POST'])
def borrar_datos():
    """Borra datos de inventario para una bodega y fecha especifica"""
    clave = request.args.get('key', '')
    if clave != 'ChiosCostos2026':
        return jsonify({'error': 'no autorizado'}), 403
    conn = None
    try:
        data = request.get_json() or {}
        fecha = data.get('fecha')
        local = data.get('local')
        if not fecha or not local:
            return jsonify({'error': 'fecha y local son requeridos'}), 400

        conn = get_db()
        cur = conn.cursor()
        # Primero borrar asignaciones relacionadas
        cur.execute("""
            DELETE FROM inventario_diario.asignacion_diferencias
            WHERE conteo_id IN (
                SELECT id FROM inventario_diario.inventario_ciego_conteos
                WHERE fecha = %s AND local = %s
            )
        """, (fecha, local))
        asig_borradas = cur.rowcount

        cur.execute("""
            DELETE FROM inventario_diario.inventario_ciego_conteos
            WHERE fecha = %s AND local = %s
        """, (fecha, local))
        conteos_borrados = cur.rowcount
        conn.commit()

        return jsonify({
            'success': True,
            'conteos_borrados': conteos_borrados,
            'asignaciones_borradas': asig_borradas
        })
    except Exception as e:
        print(f"Error en /api/admin/borrar-datos: {e}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if conn:
            release_db(conn)


@app.route('/api/admin/actualizar-costos', methods=['POST'])
def actualizar_costos():
    """Actualiza costo_unitario - acepta costos pre-calculados o lista de pendientes"""
    clave = request.args.get('key', '')
    if clave != 'ChiosCostos2026':
        return jsonify({'error': 'no autorizado'}), 403
    try:
        data = request.get_json() or {}

        # Modo 1: costos pre-calculados {nombre: costo}
        costos_directos = data.get('costos', {})
        if costos_directos:
            conn_inv = get_db()
            cur_inv = conn_inv.cursor()
            total = 0
            for nombre, costo in costos_directos.items():
                cur_inv.execute("""
                    UPDATE inventario_diario.inventario_ciego_conteos
                    SET costo_unitario = %s
                    WHERE nombre = %s AND (costo_unitario IS NULL OR costo_unitario = 0)
                """, (float(costo), nombre))
                total += cur_inv.rowcount
            conn_inv.commit()
            release_db(conn_inv)
            return jsonify({
                'productos_recibidos': len(costos_directos),
                'registros_actualizados': total
            })

        # Modo 2: devolver lista de productos sin costo
        conn_inv = get_db()
        cur_inv = conn_inv.cursor()
        cur_inv.execute("""
            SELECT DISTINCT nombre FROM inventario_diario.inventario_ciego_conteos
            WHERE costo_unitario IS NULL OR costo_unitario = 0
        """)
        nombres = [r['nombre'] for r in cur_inv.fetchall()]
        release_db(conn_inv)
        return jsonify({'pendientes': nombres, 'total': len(nombres)})
    except Exception as e:
        return jsonify({'error': str(e)}), 500


def _cargar_personas_airtable():
    """Carga personas desde Airtable y actualiza cache del servidor"""
    import urllib.request, json as json_lib
    todos = []
    offset = None
    while True:
        url = f'https://api.airtable.com/v0/{AIRTABLE_BASE}/{AIRTABLE_TABLE}?pageSize=100'
        url += '&fields%5B%5D=nombre&fields%5B%5D=estado'
        if offset:
            url += f'&offset={offset}'
        req = urllib.request.Request(url, headers={'Authorization': f'Bearer {_get_airtable_token()}'})
        data = json_lib.loads(urllib.request.urlopen(req, timeout=10).read())
        for r in data.get('records', []):
            f = r.get('fields', {})
            if f.get('estado') == 'Activo':
                nombre = f.get('nombre', '')
                if nombre:
                    todos.append(nombre)
        offset = data.get('offset')
        if not offset:
            break
    resultado = sorted(set(todos))
    _personas_cache['datos'] = resultado
    _personas_cache['timestamp'] = _time.time()
    return resultado


def _obtener_personas():
    """Obtiene personas desde cache o Airtable si cache expirado"""
    ahora = _time.time()
    if _personas_cache['datos'] and (ahora - _personas_cache['timestamp']) < PERSONAS_CACHE_TTL:
        return _personas_cache['datos']
    try:
        return _cargar_personas_airtable()
    except Exception as e:
        print(f'Error cargando personas de Airtable: {e}')
        # Devolver cache viejo si existe
        return _personas_cache['datos'] if _personas_cache['datos'] else []


@app.route('/api/personas', methods=['GET'])
def get_personas():
    try:
        personas = _obtener_personas()
        return jsonify(personas)
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/inventario/asignaciones', methods=['GET'])
def get_asignaciones():
    fecha = request.args.get('fecha')
    local = request.args.get('local')
    if not fecha or not local:
        return jsonify({'error': 'fecha y local son requeridos'}), 400
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT a.id, a.conteo_id, a.persona, a.cantidad
            FROM inventario_diario.asignacion_diferencias a
            JOIN inventario_diario.inventario_ciego_conteos c ON a.conteo_id = c.id
            WHERE c.fecha = %s AND c.local = %s
            ORDER BY a.conteo_id, a.id
        """, (fecha, local))
        rows = cur.fetchall()
        release_db(conn)
        result = {}
        for r in rows:
            cid = str(r['conteo_id'])
            if cid not in result:
                result[cid] = []
            result[cid].append({
                'id': r['id'],
                'persona': r['persona'],
                'cantidad': float(r['cantidad'])
            })
        return jsonify({'asignaciones': result})
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/inventario/guardar-asignaciones', methods=['POST'])
def guardar_asignaciones():
    data = request.json
    conteo_id = data.get('conteo_id')
    asignaciones = data.get('asignaciones', [])
    if not conteo_id:
        return jsonify({'error': 'conteo_id es requerido'}), 400
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("""
            DELETE FROM inventario_diario.asignacion_diferencias
            WHERE conteo_id = %s
        """, (conteo_id,))
        for a in asignaciones:
            if a.get('persona') and a.get('cantidad') and float(a['cantidad']) > 0:
                cur.execute("""
                    INSERT INTO inventario_diario.asignacion_diferencias (conteo_id, persona, cantidad)
                    VALUES (%s, %s, %s)
                """, (conteo_id, a['persona'].strip(), float(a['cantidad'])))
        conn.commit()
        release_db(conn)
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/health', methods=['GET'])
def health():
    return jsonify({'status': 'ok'})


@app.route('/api/debug-db', methods=['GET'])
def debug_db():
    """Diagnostico de conexion a BD"""
    import traceback
    result = {'pool_status': 'unknown', 'direct_conn': 'unknown'}
    # Test 1: pool connection
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("SELECT 1 as test, current_timestamp as ts, version() as ver")
        row = cur.fetchone()
        result['pool_status'] = 'ok'
        result['pool_data'] = {'test': row['test'], 'ts': str(row['ts']), 'ver': row['ver'][:60]}
        release_db(conn)
    except Exception as e:
        result['pool_status'] = 'error'
        result['pool_error'] = str(e)
        result['pool_traceback'] = traceback.format_exc()
    # Test 2: direct connection (bypass pool)
    try:
        conn2 = psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)
        cur2 = conn2.cursor()
        cur2.execute("SELECT COUNT(*) as cnt FROM inventario_diario.usuarios")
        row2 = cur2.fetchone()
        result['direct_conn'] = 'ok'
        result['direct_data'] = {'usuarios_count': row2['cnt']}
        conn2.close()
    except Exception as e:
        result['direct_conn'] = 'error'
        result['direct_error'] = str(e)
        result['direct_traceback'] = traceback.format_exc()
    result['db_config_host'] = DB_CONFIG['host']
    result['db_config_db'] = DB_CONFIG['database']
    return jsonify(result)


@app.route('/api/debug-personas', methods=['GET'])
def debug_personas():
    """Endpoint de diagnostico para el cache de personas"""
    ahora = _time.time()
    cache_age = ahora - _personas_cache['timestamp'] if _personas_cache['timestamp'] > 0 else -1
    token = _get_airtable_token()
    return jsonify({
        'cache_count': len(_personas_cache['datos']),
        'cache_age_seconds': round(cache_age, 1),
        'cache_ttl': PERSONAS_CACHE_TTL,
        'cache_expired': cache_age > PERSONAS_CACHE_TTL if cache_age >= 0 else True,
        'airtable_token_configured': bool(token),
        'token_length': len(token) if token else 0,
        'env_keys_with_air': [k for k in os.environ.keys() if 'AIR' in k.upper()],
        'primeras_3': _personas_cache['datos'][:3] if _personas_cache['datos'] else []
    })

import threading
def _precargar_personas():
    for intento in range(6):
        token = _get_airtable_token()
        if not token:
            print(f'Pre-carga intento {intento+1}: AIRTABLE_TOKEN vacio, reintentando en 5s...')
            _time.sleep(5)
            continue
        try:
            _cargar_personas_airtable()
            print(f'Pre-carga personas OK (intento {intento+1}): {len(_personas_cache["datos"])} personas')
            return
        except Exception as e:
            print(f'Pre-carga intento {intento+1} error: {e}')
            _time.sleep(5)
    print('Pre-carga personas FALLO despues de 6 intentos')
threading.Thread(target=_precargar_personas, daemon=True).start()

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 10000))
    app.run(host='0.0.0.0', port=port, debug=False)
